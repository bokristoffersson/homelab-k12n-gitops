name: heatpump-settings-api CI/CD

on:
  push:
    branches: [main]
    paths:
      - "applications/heatpump-settings-api/**"
      - ".github/workflows/heatpump-settings-api.yml"
  pull_request:
    branches: [main]
    paths:
      - "applications/heatpump-settings-api/**"
      - ".github/workflows/heatpump-settings-api.yml"

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: bokristoffersson/heatpump-settings-api

jobs:
  test:
    name: Test
    runs-on: homelab-runners
    env:
      RUSTFLAGS: ""  # Override setup-rust-toolchain's -D warnings
    defaults:
      run:
        working-directory: applications/heatpump-settings-api
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install build dependencies
        uses: ./.github/actions/setup-rust-build-tools

      - name: Setup Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy

      - name: Check formatting
        run: cargo fmt -- --check

      - name: Run clippy
        run: cargo clippy --all-targets --all-features

      - name: Run tests
        run: cargo test --verbose

  docker:
    name: Build and Push Docker Image
    runs-on: homelab-runners
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl and kubeconfig
        run: |
          # Install kubectl if needed
          if ! command -v kubectl &> /dev/null; then
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/arm64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi

          # Set up kubeconfig from runner's default location
          mkdir -p $HOME/.kube
          if [ -f /etc/rancher/k3s/k3s.yaml ]; then
            # If k3s config exists on the runner, use it
            cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
            chmod 600 $HOME/.kube/config
          elif [ ! -z "$KUBECONFIG_DATA" ]; then
            # Otherwise use KUBECONFIG_DATA secret if provided
            echo "$KUBECONFIG_DATA" | base64 -d > $HOME/.kube/config
            chmod 600 $HOME/.kube/config
          fi

          kubectl version --client
          kubectl cluster-info
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}

      - name: Build and push with Kaniko
        run: |
          # Create Docker config secret first
          kubectl create secret generic kaniko-docker-config-${{ github.run_id }} \
            --from-literal=config.json="{\"auths\":{\"${{ env.REGISTRY }}\":{\"auth\":\"$(echo -n ${{ github.actor }}:${{ secrets.GITHUB_TOKEN }} | base64)\"}}}" \
            --namespace=default

          # Create Kaniko pod spec
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Pod
          metadata:
            name: kaniko-build-${{ github.run_id }}
            namespace: default
          spec:
            restartPolicy: Never
            containers:
            - name: kaniko
              image: gcr.io/kaniko-project/executor:v1.23.2
              args:
              - "--context=git://github.com/${{ github.repository }}.git#refs/heads/main"
              - "--context-sub-path=applications/heatpump-settings-api"
              - "--dockerfile=Dockerfile"
              - "--destination=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main"
              - "--destination=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
              - "--cache=true"
              - "--cache-repo=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/cache"
              - "--custom-platform=linux/arm64"
              volumeMounts:
              - name: docker-config
                mountPath: /kaniko/.docker
            volumes:
            - name: docker-config
              secret:
                secretName: kaniko-docker-config-${{ github.run_id }}
          EOF

          # Wait for pod to complete
          kubectl wait --for=condition=Ready pod/kaniko-build-${{ github.run_id }} --namespace=default --timeout=600s || true

          # Stream logs
          kubectl logs -f kaniko-build-${{ github.run_id }} --namespace=default || true

          # Check if pod succeeded
          POD_STATUS=$(kubectl get pod kaniko-build-${{ github.run_id }} --namespace=default -o jsonpath='{.status.phase}')

          # Cleanup
          kubectl delete pod kaniko-build-${{ github.run_id }} --namespace=default || true
          kubectl delete secret kaniko-docker-config-${{ github.run_id }} --namespace=default || true

          # Exit with error if build failed
          if [ "$POD_STATUS" != "Succeeded" ]; then
            echo "Kaniko build failed with status: $POD_STATUS"
            exit 1
          fi
